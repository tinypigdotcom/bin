#!/usr/bin/perl

# TODO
# * implement tags
# * implement delete entry
# * implement edit individual entry
# * Implement word option
# * Differentiate title and allow for title search
# * allow input from file

use strict;
use warnings FATAL => 'all';

use Data::Dumper;
use Getopt::Long;
use IO::File;

my $nf = $ENV{NOTEFILES} || "$ENV{HOME}/info/notes.txt";
my @notefiles = split ':', $nf;

our $VERSION = '0.8';

my $title      = '';
my $edit       =  0;
my $word       =  0;
my $add        =  0;
my $help       =  0;

my $separator = "%%%\n";

GetOptions(
    "title=s" => \$title,
    "word"    => \$word,
    "add"     => \$add,
    "help"    => \$help,
    "edit"    => \$edit,
) or die("Error in command line arguments\n");

sub usage {
    return <<EOF;
Usage: note [OPTION]... PATTERN...
Add or retrieve a note
Example: note lawnmower

-a, --add       Add a note
-t, --title     Title for the note being added
-w, --word      Only find if PATTERN is a word
-e, --edit      Edit the notes file
EOF
}

sub errout {
}

sub edit_notes {
    my $editor = $ENV{EDITOR} || 'vim';
    my $paths = join(' ', @notefiles);
    system("$editor $paths");
}

my @output_lines;
sub output {
    my $output_line = join('',@_);
    push @output_lines, $output_line;
}

sub search_note {
    my (@patterns) = @_;

    my @notes;
    for my $file (@notefiles) {
        my $ifh = IO::File->new( $file, '<' );
        die if ( !defined $ifh );

        my $contents = do { local $/; <$ifh> };

        $ifh->close;
        push @notes, split(/^$separator/m, $contents);
    }

    my %matches;
    OUTER: for (@notes) {
        for my $pattern (@patterns) {
            next OUTER unless /$pattern/i;
        }
        s/^/  /mg;
        $matches{$_}++;
    }
    my $output_separator = "\n" . '+' . '=' x 78 . "\n|";
    my $title_separator  = "\n" . '+' . '-' x 68 . "\n";
    my $gpg_file = "$ENV{HOME}/.note.gpg";
    if (%matches) {
        for my $match (keys %matches) {
            my @lines = split "\n", $match;
            my $title = shift @lines;
            $title =~ s/^\s*//;
            my $body = join "\n", @lines;
            $body =~ s/\s*$//s;
            output $output_separator,
                   " $title",
                   $title_separator;
            if ($body =~ /BEGIN PGP MESSAGE.*END PGP MESSAGE/s) {
                my $ofh = IO::File->new($gpg_file, '>');
                die if (!defined $ofh);
                $body =~ s/^ *//mg;
                print $ofh $body;
                $ofh->close;
                if ( -r $gpg_file ) {
                    system("gpg --decrypt $gpg_file && rm $gpg_file");
                }
            }
            else {
                output $body, "\n";
                my $cfh = IO::File->new('/dev/clipboard', '>');
                if (defined $cfh) {
                    print $cfh $body;
                    $cfh->close;
                }
            }
        }
        output "\n";
    }
    else {
        output "No match.\n";
    }
    open O, '| less -FX' or die;
    print O @output_lines;
    close O;
}

sub add_note {
    print "Make note:\n";

    my $note_title = "$title\n";
    my $note;
    while (my $input_line = <STDIN>) {
        $note .= $input_line;
        if ( $note_title !~ /\w/ && $input_line =~ /\w/ ) {
            $note_title = $input_line;
        }
    }

    my $ofh = IO::File->new( $notefiles[0], '>>' );
    die if ( !defined $ofh );

    print $ofh "${separator}${note_title}${note}\n";
    $ofh->close;
}

sub main {
    my (@patterns) = @_;

    if    ($help)     { die usage()              }
    elsif ($edit)     { edit_notes()             }
    elsif (@patterns) { search_note( @patterns ) }
    elsif ($add)      { add_note()               }
    else              { die usage()              }

    return;
}

my $rc = ( main(@ARGV) || 0 );

exit $rc;

