#!/usr/bin/perl

# purpose: list all personal commands on this system

# maybe use warnings FATAL => 'all';

# TODO
# * create tests which could fix dumb errors

use Modern::Perl '2014';use warnings;our$VERSION='v0.1.7';package ComsScript{use Carp;use Data::Dumper;use Hash::Util qw(lock_keys);our$VAR1;my$persist_file="$ENV{HOME}/.coms_script";my$do_persist=0;my$DEBUG=0;

my @keys = qw( argv switches pattern coms_switch2 input_file );

sub run {
    my ( $self, @argv ) = @_;
    $self->{argv} = \@argv;

    $self->check_inputs();

    $self->main_coms_run();
    $self->freeze_me();
    return 0;    # return for entire script
}

sub main_coms_run {
    my ($self) = @_;

    my $pattern = $self->{pattern};

    chdir $ENV{HOME} || die "can't chdir $ENV{HOME}: $!";
    my @bins = grep { /^bin\d?/ && -d "./$_" } get_directory();
    my @files;
    my %comsignore;
    for my $bin ( @bins ) {
        push @files, map { "$bin/$_" } grep { !/^\./ } get_directory($bin);
        my $ignorefile = "$bin/.comsignore";
        if ( -r $ignorefile ) {

            my $ifh = IO::File->new($ignorefile, '<');
            die if (!defined $ifh);

            while(<$ifh>) {
                chomp;
                s/^\s*//;
                s/\s*$//;
                $comsignore{"$bin/$_"}++;
            }
            $ifh->close;

        }
    }

    my $print_file;
    my $print_text;
    for my $file ( @files ) {
        my $ifh = IO::File->new( $file, '<' );
        die "can't open $file: $!" if ( !defined $ifh );

        my $found=0;
        next if $comsignore{$file};
        while (<$ifh>) {
            chomp;
            if ( /#\s*purpose:\s*(.*)/ ) {
                $found++;
                my $text = $1;
                if ( $text ) {
                    $print_file = $file;
                    $print_text = $text;
                }
                last;
            }
        }
        $ifh->close;
        if ( !$found ) {
            $print_file = $file;
            $print_text = '???';
        }
        my $output_line = sprintf("%-25s $print_text", $print_file);
        if ( !$pattern || ( $pattern && $output_line =~ /$pattern/i )) {
            print "$output_line\n";
        }
    }
}

sub usage {
    croak "This is a function, not a method" if ( ref $_[0] );

    return <<EOF;
Usage: coms
list all personal commands on this system
EOF
}

sub check_inputs {
    my ( $self ) = @_;
    my %valid_switch = ();
    while ( my $arg = shift( @{ $self->{argv} } ) ) {
        if ( $arg =~ /^(-.*)/ ) {
            my $switch = $1;
            if ( $switch eq '-?' or $switch eq '-h' or $switch eq '--help' )
            {
                print STDERR usage();
                exit 2;
            }
            if ( !$valid_switch{$switch} ) {
                errout("bad switch $switch");
            }
            $self->{ $valid_switch{$switch} }++;
        }
        else {
            if ( @{ $self->{argv} } > 0 ) {
                errout(
                    message  => "too many arguments",
                    no_usage => 1
                );
            }
            $self->{pattern} = $arg;
            last;
        }
    }
}

 # ================== END MAIN =================================================

    sub new {
        my ($class) = @_;

        my $self = {};
        bless $self, $class;
        thaw_me( \$self );
        lock_keys( %$self, @keys );

        return $self;
    }

    sub errout {
        croak "This is a function, not a method" if ( ref $_[0] );

        my %params;
        if ( @_ == 1 ) {
            $params{message} = $_[0];
        }
        else {
            %params = @_;
        }
        my $message = "error: $params{message}\n";
        if ( !$params{no_usage} ) {
            $message .= usage();
        }
        die $message;
    }

    sub thaw_me {
        return unless $do_persist;

        my ($self) = @_;

        return unless thaw($persist_file);

        ${$self} = $VAR1;

        if ($DEBUG) {
            warn "thawed!\n", Dumper($self);
        }
        if ( !defined $self ) {
            croak "failed eval of dump";
        }
    }

    sub freeze_me {
        return unless $do_persist;

        my ($self) = @_;
        $self->freeze( $persist_file, $self );
    }

    sub thaw {
        croak "This is a function, not a method" if ( ref $_[0] );

        my ($filename) = @_;

        my $ifh = IO::File->new( $filename, '<' );
        return if ( !defined $ifh );

        my $contents = do { local $/; <$ifh> };
        $ifh->close;

        return eval $contents;
    }

    sub freeze {
        croak "This is a function, not a method" if ( ref $_[0] );

        my ( $filename, $ref ) = @_;

        my $ofh = IO::File->new( $filename, '>' );
        croak "Failed to open output file: $!" if ( !defined $ofh );

        print $ofh Dumper($ref);
        $ofh->close;
    }

    sub random {
        croak "This is a function, not a method" if ( ref $_[0] );

        my ( $max, $min ) = @_;

        $min //= 1;
        if ( $min > $max ) {
            ( $min, $max ) = ( $max, $min );
        }
        my $range = $max - $min;
        return int( rand( $range + 1 ) ) + $min;
    }

    # example
    # my @dot_files = grep { /^\./ && -f "$some_dir/$_" } get_directory($target);
    sub get_directory {
        croak "This is a function, not a method" if ( ref $_[0] );

        my ($dir) = @_;
        $dir ||= '.';

        opendir(my $dh, $dir) || die "can't opendir $dir: $!";
        my @files = readdir($dh);
        closedir $dh;

        return @files;
    }
}

package main;

my $app = ComsScript->new();
exit $app->run(@ARGV);

